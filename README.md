Catbuffer C++ Generator
=======================

A simple C++ code generator for serializing and deserializing Catbuffer schemas.

![img](https://pbs.twimg.com/media/B8AZgE-CUAAIB4a.jpg)


# Overview
----------
Catbuffer is a very simple and memory efficient data serialization format. No extra information or padding is read or written, apart from what is defined by the user.
Catbuffer is the serialization mechanism originally developed for the Symbol blockchain to serialize and deserialize data structures for sending and receiving data between network clients. It consist of three components. The **catbuffer-schema**, which is the interface description language used to define the data structures; The **catbuffer-parser** which parses the schemas and generates a .yaml output file; The **catbuffer-generator** which takes the generated .yaml file as input and generates C++ files which are compiled into a library. The process is shown below: 

**catbuffer-schema** --> **catbuffer-parser** --> .yaml file --> **catbuffer-generator** --> .cpp/.h files --> C++ lib file

Note that it is possible to define data structures directly in YAML format instead of catbuffer schemas, however, using schemas is more human readable and less verbose to write.


## Instructions

To generate the library file, do the following:


1. Clone the ``catbuffer-generators`` repository:

```bash
git clone https://github.com/symbol/catbuffer-generators
```

2. Generated the .cpp/.h files:

```bash
python3 -m generator input_file.yaml output_directory/
```

3. Enter the 'output_directory' where files have been generated:

```bash
cd output_directory
```

4. Create a director to build library:

```bash
mkdir _build && cd _build
```

5. Generate CMake files:

```bash
cmake ..
```

6. Compile library

```bash
make
```

You should now see a file called **libcatbuffer.a** which you can link to you program in order to serialize/deserialize the data structures you defined in your schemas or .yaml file.


## Repository Structure
------------------------

* **[`generator`](generator/)**: The python source code for parsing an input YAML file and outputting C++ code.
* **[`cpp_source`](cpp_source/)**: Static C++ source code needed for serialization/deserialization, which is independent of an input YAML file.
* **[`cpp_build_files`](cpp_build_files/)**: C++ build files for compiling the code generated by the generator.
* **[`unit_tests`](unit_tests/)**: Unit tests to test the code in the **generator/** folder.
* **[`yaml_test_inputs`](yaml_test_inputs/)**: YAML input files for testing.
* **[`test_vectors`](test_vectors/)**: test vector corresponding to the yaml test inputs in the **yaml_test_inputs/** folder.
* **[`end_to_end_test`](end_to_end_test/)**: Contains end to end tests where serialized inputs are deserialized and then serialized again to check that the output is equal to the input. The test takes the yaml inputs in the 'yaml_test_inputs' folder, generates C++ outputs, takes the test vectors in 'test_vectors', uses the generated code to deserialize input vectors and then serializes again to compare the result with the initial input vectors.


[//]: # (TODO: add a testing subsection here)

# YAML Input File Format
-------------------------

An example of a simple data structure defined in YAML is shown below:

```yaml
- name: Coordinate
  type: struct
  comments: a structure for storing a 3D coordinate
  
  layout:
  - name: x
    type: int32
    comments: the x coordinate

  - name: y
    type: int32
    comments: the y coordinate
  
  - name: z
    type: int32
    comments: the z coordinate
```

The above markup defines a structure called **Coordinate** with 3 fields called *x*, *y* and *z* of type *int32*. Note that the comment fields are optional.


## Builtin Data Types

Catbuffer supports the following builtin datatypes: 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64'


##  Custom Data Types

Apart from the builtin types, custom types can be defined like so:

```yaml
- name: FeeMultiplier
  type: uint16
```

or

```yaml
- name: Address
  size: 24
  type: array uint8
```

In C++, the above two examples would be equivalent to:

```c++
using BlockFeeMultiplier = uint32_t;
```
and 

```c++
using Address = struct Address_t { uint8_t data[24]; };
```

Custom types can be useful for type checking and can be used when defining structs.


## Defining Enumeration

An enum can be defined like so:

```yaml
- name: NetworkType
  comments: enumeration of network types
  type: enum uint8

  values:
  - name: MAINNET
    comments: public network
    value: 104
    
  - name: TESTNET
    comments: public test network
    value: 152
```

which would be equivalent to this in C++:


```c++
/**
 * enumeration of network types
 */
enum class NetworkType : uint8_t
{
	MAINNET = 104, //< public network
	TESTNET = 152, //< public test network
};
```

## Defining Structs

Structs are the most elaborate custom defined types in Catbuffer and can contain multiple fields including other structs. A struct has to define at least three keys: 'name', 'type' and 'layout'. An optional 'comment' key can also be added. The 'type' key has to be set to 'struct' and 'layout' defines the fields in the struct. An example of a 'struct' was shown [here](#yaml_input_file_format). There are in total 9 field types that can appear inside 'layout'. They are listed below:

*builtin type*

*custom type*



*condition*

*reserved*

*const*

*inline*



*array*

*array sized*

*array fill*


The subsections below will explain the above field types in more detail.


### Builtin Type Field

Builtin types are the simplest types supported in Catbuffer:

```yaml
- name: time_elapsed
  type: uint64

- name: address
  type: array uint8
```


### Custom Type Field

Some custom types such as **NetworkType**, **FeeMultiplier**, **Coordinate** were defined [here](#defining_enumeration), [here](#custom_data_types) and [here](#yaml_input_file_format). Below they are shown as fields in a struct:

```yaml
- name: network
  type: NetworkType
 ```
 
```yaml
- name: multiplier
  type: FeeMultiplier
```

```yaml
- name: coordinate
  type: Coordinate
```



### Condition Field

Condition fields can be used to add optional fields. If a condition is met then then field is serialized, otherwise it is ignored. Below is an example of a condition field:

```yaml
- name: msg
  type: Message
  condition: message_defined
  condition_operation: not equals
  condition_value: 0
```

The name of the field is 'msg' and is of custom type 'Message'. It is only serialized/deserialized if **message_defined != 0**. Note that **message_defined** has to be a field in the same struct. The only condition operations supported at the moment are **equals** and **not equals**.



### Reserved Field

Reserved fields are useful for when a field is reserved for future use and should have a specific value that can not be set by the user. It is also useful for adding padding. Reserved fields are defined like [builtin](#builtin_type_field) fields but also need to add a **value** key and a **disposition** key with the value **reserved**. Below is an example of how to define a reserved field for padding:

```yaml
  - name: padding
    type: uint32
    value: 0
    disposition: reserved
    comments: reserved padding to align next field on 8-byte boundary
```

Note that when serializing/deserializing, if the value read for a reserved field does not equal the **value** key, it is considered an error and the serialization/deserialization will fail.

TODO: Value check is still to be implemented. Some questions: should reserved fields always have a value? Should reserved fields appear as class members?



### Inline Field

Inline fields can be used to inline structs into other structs, so that instead of doing *OuterStruct.InnerStruct.my_variable*, one can do *OuterStruct.my_variable*. An example of how to do an inline field is shown below

```yaml
  - type: Coordinate
    disposition: inline
```



### Const Field

It is possible to define constants in Catbuffer. Although they are not read or written when serializing, they are included as class members when generating code. They can be defined like so:

```yaml
  name: VERSION
  type: unit8
  value: 14
  disposition: const
```

Which would generate a C++ class member similar to this:

```c++
const uint8_t VERSION = 14;
```

(TODO: just do "type: const unit8" and get rid of disposition)



### Array Field
An array field is just a normal fixed size array with elements of a fixed size.

```yaml
  - name: amounts
    size: amount_size
    disposition: array
    type: uint64
```

Note that **amount_size** has to be a field in the same struct which appears before the array field. Furthermore, note that **type** can also be a user defined type, but the size of each array element must be the same for all elements, which means that they can not contain arrays of different sizes for example (TODO: ask the core devs about this)

(TODO: missing check)
(TODO: no need for disposition, just do "type: array uint64")


### Array Sized Field

An array sized field is an array where the number of elements is not known, but where the total array size in bytes is known. This is useful for arrays where each element is of a different type and size. The array elements in this case are of user defined custom types, however, all elements must share a common header field, which in turn contains a field which indicates what the element type is. The header type is indicated with the **header** key and the field within the header, containing the element type, is indicated with the **header_type_field** key. An example of this is shown below:

```yaml
  - name: transactions
    disposition: array sized
    size: payload_size
    header: EmbeddedTransaction
    header_type_field: elem_type
```

In the above example the total size of the array in bytes is given in the **size** key. '**EmbeddedTransaction**' is the header which is common to all elements in the '**transactions**' array. The field in the '**EmbeddedTransaction**' which indicates the type of an element is called '**elem_type**'. The type of the '**elem_type**' field itself has to be an enum.  

Given an array sized field, Catbuffer will automagically know how to serialize and deserialize. For this to happen, the elements in the array also need to be defined with a specific const called **TRANSACTION_TYPE** with an enum type as shown below: 

```yaml
  - name: TRANSACTION_TYPE
    type: TransactionType     # Enum defined somewhere else.
    value: MOSAIC_DEFINITION  # Enumerator in TransactionType.
    disposition: const
```

**MOSAIC_DEFINITION** in this case is an enumerator in the **TransactionType** enum, which also has to be the type of the **elem_type** field mentioned above.


( TODO: const should not be used for this. )
( TODO: We need to think about this a bit more. What if there are two fields of type EmbeddedTransaction? What if its not inline? )
( TODO: change "disposition" key to "type" )


### Array Fill Field

An 'array fill' is a normal array with fixed sized elements, but where the number of elements is computed based on how much data is still pending to be serialized/deserialized. So for example if the total amount of data to deserialize is 'n' bytes and 'm' bytes of data is still pending to be serialized, then the size of the array is 'n-m' bytes. An 'array fill' field is defined like so:

```yaml
    name: signatures
    disposition: array fill
    size: 0
    type: Signature
```

Note that an 'array fill' field has to be the last field in the outermost struct, otherwise it is an error.

(TODO: remove size field since it is not needed)
(TODO: implement check)
(TODO: Explain why the need for array fill. Is it because we can save a size field?)


# Generator code

The generator code, defined in the **generator/** folder, contains multiple classes to convert YAML inputs to C++ code. There are two types of classes, the ones that generate C++ declaration code which goes into .h files and definition code which goes into .cpp files. Below is a quick overview of the main classes:


|Declaration Classes          | Description                                                                     | 
|-----------------------------|---------------------------------------------------------------------------------|
|CppClassMemberGenerator      | Takes fields defined in YAML and converts them to C++ class members.            |
|CppClassDeclarationGenerator | Generates C++ class declarations which go into **.h** files.                    |
|CppTypesGenerator            | Converts enums and custom types defined in YAML and outputs them in **types.h**.|


|Definition Classes            | Description                                                                                     |
|------------------------------|-------------------------------------------------------------------------------------------------|
|CppSerializationGenerator     | Takes a field generated in YAML and generates C++ code to serialize it into a raw byte buffer   |
|CppDeserializationGenerator   | Takes a field generated in YAML and generates C++ code to deserialize it from a raw byte buffer |
|CppClassDefinitionGenerator   | Generates C++ class definitions which go into **.cpp** files.                                   |
|CppEnumeratorToClassGenerator | Generates C++ functions to convert from enums to class instances.                               |

All of the above classes are documented in more detail in the source code.


# C++ generated files
---------------------

When done parsing a YAML input file three different C++ files are generated. First **types.h** files are generated, which contain all simple custom types and enums. Then for each defined struct type, C++ class files are generated in **.cpp/.h**, which contain the defined fields as class members and implement the ICatbuffer interface. The ICatbuffer interface is explained below. Lastly the files converters.h/converters.cpp contain the functions necessary to convert an enumerator to an instance of a struct as explained [here](#array_sized_field).


## ICatBuffer interface
The ICatBuffer interface declares methods for serializing and deserializing raw byte buffers. It also declares a method for getting the total size of all fields in serialized form. All structs declared in the input YAML file are converted to C++ classes that inherit from ICatbuffer. This allows structs to be initialized by deserialization. The 'ICatBuffer.h' header file is defined in the **cpp_source/** folder.


## RawBuffer
Rawbuffer is the buffer which is declared in the ICatBuffer interface as input for the serializer and deserializer methods. It is therefore compiled and added in the output C++ library file. Rawbuffer implements a simple buffer handling functionality with out of bounds protection.
